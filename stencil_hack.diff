1c1,7
< 'use strict';
---
> // 'use strict';
> // Object.defineProperty(exports, '__esModule', { value: true });
> var global = self;
> self.__stencil__ = {
>   registry: [],
>   internals: {}
> }
3c9,11
< Object.defineProperty(exports, '__esModule', { value: true });
---
> self.__stencil__.fetchRegisteredComponents = function() {
>   return [].concat(self.__stencil__.registry)
> }
5306c5314,5339
< class AppRoot {
---
> 
> __stencil__.internals = {
>   registerInstance: (...args) => this.registerInstance(...args),
>   h: (...args) => h(...args),
> }
> 
> // class AppRoot {
> //     constructor(hostRef) {
> //         registerInstance(this, hostRef);
> //     }
> //     render() {
> //         return (h("div", null, h("h1", null, `I render ${this.wham}`)));
> //     }
> //     static get cmpMeta() { return {
> //         "$flags$": 0,
> //         "$tagName$": "tomp-custom-element",
> //         "$members$": {
> //             "wham": [1]
> //         },
> //         "$listeners$": undefined,
> //         "$lazyBundleId$": "-",
> //         "$attrsToReflect$": []
> //     }; }
> // }
> 
> class AppRoot$1 {
5396,5463c5429,5496
< const createProviderConsumer = (defaultState, consumerRender) => {
<     let listeners = new Map();
<     let currentState = defaultState;
<     const updateListener = (fields, instance) => {
<         if (Array.isArray(fields)) {
<             [...fields].forEach(fieldName => {
<                 instance[fieldName] = currentState[fieldName];
<             });
<         }
<         else {
<             instance[fields] = Object.assign({}, currentState);
<         }
<     };
<     const subscribe = (instance, propList) => {
<         if (!listeners.has(instance)) {
<             listeners.set(instance, propList);
<             updateListener(propList, instance);
<         }
<         return () => {
<             if (listeners.has(instance)) {
<                 listeners.delete(instance);
<             }
<         };
<     };
<     const Provider = ({ state }, children) => {
<         currentState = state;
<         listeners.forEach(updateListener);
<         return children;
<     };
<     const Consumer = (props, children) => {
<         // The casting on subscribe is to allow for crossover through the stencil compiler
<         // In the future we should allow for generics in components.
<         return consumerRender(subscribe, children[0]);
<     };
<     const injectProps = (Cstr, fieldList) => {
<         const CstrPrototype = Cstr.prototype;
<         const cstrConnectedCallback = CstrPrototype.connectedCallback;
<         const cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;
<         CstrPrototype.connectedCallback = function () {
<             subscribe(this, fieldList);
<             if (cstrConnectedCallback) {
<                 return cstrConnectedCallback.call(this);
<             }
<         };
<         CstrPrototype.disconnectedCallback = function () {
<             listeners.delete(this);
<             if (cstrDisconnectedCallback) {
<                 cstrDisconnectedCallback.call(this);
<             }
<         };
<     };
<     return {
<         Provider,
<         Consumer,
<         injectProps
<     };
< };
< 
< var ActiveRouter = createProviderConsumer({
<     historyType: 'browser',
<     location: {
<         pathname: '',
<         query: {},
<         key: ''
<     },
<     titleSuffix: '',
<     root: '/',
<     routeViewsUpdated: () => { }
---
> const createProviderConsumer = (defaultState, consumerRender) => {
>     let listeners = new Map();
>     let currentState = defaultState;
>     const updateListener = (fields, instance) => {
>         if (Array.isArray(fields)) {
>             [...fields].forEach(fieldName => {
>                 instance[fieldName] = currentState[fieldName];
>             });
>         }
>         else {
>             instance[fields] = Object.assign({}, currentState);
>         }
>     };
>     const subscribe = (instance, propList) => {
>         if (!listeners.has(instance)) {
>             listeners.set(instance, propList);
>             updateListener(propList, instance);
>         }
>         return () => {
>             if (listeners.has(instance)) {
>                 listeners.delete(instance);
>             }
>         };
>     };
>     const Provider = ({ state }, children) => {
>         currentState = state;
>         listeners.forEach(updateListener);
>         return children;
>     };
>     const Consumer = (props, children) => {
>         // The casting on subscribe is to allow for crossover through the stencil compiler
>         // In the future we should allow for generics in components.
>         return consumerRender(subscribe, children[0]);
>     };
>     const injectProps = (Cstr, fieldList) => {
>         const CstrPrototype = Cstr.prototype;
>         const cstrConnectedCallback = CstrPrototype.connectedCallback;
>         const cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;
>         CstrPrototype.connectedCallback = function () {
>             subscribe(this, fieldList);
>             if (cstrConnectedCallback) {
>                 return cstrConnectedCallback.call(this);
>             }
>         };
>         CstrPrototype.disconnectedCallback = function () {
>             listeners.delete(this);
>             if (cstrDisconnectedCallback) {
>                 cstrDisconnectedCallback.call(this);
>             }
>         };
>     };
>     return {
>         Provider,
>         Consumer,
>         injectProps
>     };
> };
> 
> var ActiveRouter = createProviderConsumer({
>     historyType: 'browser',
>     location: {
>         pathname: '',
>         query: {},
>         key: ''
>     },
>     titleSuffix: '',
>     root: '/',
>     routeViewsUpdated: () => { }
5502,5997c5535,6030
< /**
<  * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js
<  */
< /**
<  * Default configs.
<  */
< const DEFAULT_DELIMITER = '/';
< const DEFAULT_DELIMITERS = './';
< /**
<  * The main path matching regexp utility.
<  */
< const PATH_REGEXP = new RegExp([
<     // Match escaped characters that would otherwise appear in future matches.
<     // This allows the user to escape special characters that won't transform.
<     '(\\\\.)',
<     // Match Express-style parameters and un-named parameters with a prefix
<     // and optional suffixes. Matches appear as:
<     //
<     // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
<     // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
<     '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
< ].join('|'), 'g');
< /**
<  * Parse a string for the raw tokens.
<  */
< const parse = (str, options) => {
<     var tokens = [];
<     var key = 0;
<     var index = 0;
<     var path = '';
<     var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
<     var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;
<     var pathEscaped = false;
<     var res;
<     while ((res = PATH_REGEXP.exec(str)) !== null) {
<         var m = res[0];
<         var escaped = res[1];
<         var offset = res.index;
<         path += str.slice(index, offset);
<         index = offset + m.length;
<         // Ignore already escaped sequences.
<         if (escaped) {
<             path += escaped[1];
<             pathEscaped = true;
<             continue;
<         }
<         var prev = '';
<         var next = str[index];
<         var name = res[2];
<         var capture = res[3];
<         var group = res[4];
<         var modifier = res[5];
<         if (!pathEscaped && path.length) {
<             var k = path.length - 1;
<             if (delimiters.indexOf(path[k]) > -1) {
<                 prev = path[k];
<                 path = path.slice(0, k);
<             }
<         }
<         // Push the current path onto the tokens.
<         if (path) {
<             tokens.push(path);
<             path = '';
<             pathEscaped = false;
<         }
<         var partial = prev !== '' && next !== undefined && next !== prev;
<         var repeat = modifier === '+' || modifier === '*';
<         var optional = modifier === '?' || modifier === '*';
<         var delimiter = prev || defaultDelimiter;
<         var pattern = capture || group;
<         tokens.push({
<             name: name || key++,
<             prefix: prev,
<             delimiter: delimiter,
<             optional: optional,
<             repeat: repeat,
<             partial: partial,
<             pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
<         });
<     }
<     // Push any remaining characters.
<     if (path || index < str.length) {
<         tokens.push(path + str.substr(index));
<     }
<     return tokens;
< };
< /**
<  * Escape a regular expression string.
<  */
< const escapeString = (str) => {
<     return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
< };
< /**
<  * Escape the capturing group by escaping special characters and meaning.
<  */
< const escapeGroup = (group) => {
<     return group.replace(/([=!:$/()])/g, '\\$1');
< };
< /**
<  * Get the flags for a regexp from the options.
<  */
< const flags = (options) => {
<     return options && options.sensitive ? '' : 'i';
< };
< /**
<  * Pull out keys from a regexp.
<  */
< const regexpToRegexp = (path, keys) => {
<     if (!keys)
<         return path;
<     // Use a negative lookahead to match only capturing groups.
<     var groups = path.source.match(/\((?!\?)/g);
<     if (groups) {
<         for (var i = 0; i < groups.length; i++) {
<             keys.push({
<                 name: i,
<                 prefix: null,
<                 delimiter: null,
<                 optional: false,
<                 repeat: false,
<                 partial: false,
<                 pattern: null
<             });
<         }
<     }
<     return path;
< };
< /**
<  * Transform an array into a regexp.
<  */
< const arrayToRegexp = (path, keys, options) => {
<     var parts = [];
<     for (var i = 0; i < path.length; i++) {
<         parts.push(pathToRegexp(path[i], keys, options).source);
<     }
<     return new RegExp('(?:' + parts.join('|') + ')', flags(options));
< };
< /**
<  * Create a path regexp from string input.
<  */
< const stringToRegexp = (path, keys, options) => {
<     return tokensToRegExp(parse(path, options), keys, options);
< };
< /**
<  * Expose a function for taking tokens and returning a RegExp.
<  */
< const tokensToRegExp = (tokens, keys, options) => {
<     options = options || {};
<     var strict = options.strict;
<     var end = options.end !== false;
<     var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
<     var delimiters = options.delimiters || DEFAULT_DELIMITERS;
<     var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
<     var route = '';
<     var isEndDelimited = false;
<     // Iterate over the tokens and create our regexp string.
<     for (var i = 0; i < tokens.length; i++) {
<         var token = tokens[i];
<         if (typeof token === 'string') {
<             route += escapeString(token);
<             isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
<         }
<         else {
<             var prefix = escapeString(token.prefix || '');
<             var capture = token.repeat
<                 ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'
<                 : token.pattern;
<             if (keys)
<                 keys.push(token);
<             if (token.optional) {
<                 if (token.partial) {
<                     route += prefix + '(' + capture + ')?';
<                 }
<                 else {
<                     route += '(?:' + prefix + '(' + capture + '))?';
<                 }
<             }
<             else {
<                 route += prefix + '(' + capture + ')';
<             }
<         }
<     }
<     if (end) {
<         if (!strict)
<             route += '(?:' + delimiter + ')?';
<         route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
<     }
<     else {
<         if (!strict)
<             route += '(?:' + delimiter + '(?=' + endsWith + '))?';
<         if (!isEndDelimited)
<             route += '(?=' + delimiter + '|' + endsWith + ')';
<     }
<     return new RegExp('^' + route, flags(options));
< };
< /**
<  * Normalize the given path string, returning a regular expression.
<  *
<  * An empty array can be passed in for the keys, which will hold the
<  * placeholder key descriptions. For example, using `/user/:id`, `keys` will
<  * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
<  */
< const pathToRegexp = (path, keys, options) => {
<     if (path instanceof RegExp) {
<         return regexpToRegexp(path, keys);
<     }
<     if (Array.isArray(path)) {
<         return arrayToRegexp(path, keys, options);
<     }
<     return stringToRegexp(path, keys, options);
< };
< 
< const hasBasename = (path, prefix) => {
<     return (new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i')).test(path);
< };
< const stripBasename = (path, prefix) => {
<     return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
< };
< const stripTrailingSlash = (path) => {
<     return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
< };
< const addLeadingSlash = (path) => {
<     return path.charAt(0) === '/' ? path : '/' + path;
< };
< const stripLeadingSlash = (path) => {
<     return path.charAt(0) === '/' ? path.substr(1) : path;
< };
< const parsePath = (path) => {
<     let pathname = path || '/';
<     let search = '';
<     let hash = '';
<     const hashIndex = pathname.indexOf('#');
<     if (hashIndex !== -1) {
<         hash = pathname.substr(hashIndex);
<         pathname = pathname.substr(0, hashIndex);
<     }
<     const searchIndex = pathname.indexOf('?');
<     if (searchIndex !== -1) {
<         search = pathname.substr(searchIndex);
<         pathname = pathname.substr(0, searchIndex);
<     }
<     return {
<         pathname,
<         search: search === '?' ? '' : search,
<         hash: hash === '#' ? '' : hash,
<         query: {},
<         key: ''
<     };
< };
< const createPath = (location) => {
<     const { pathname, search, hash } = location;
<     let path = pathname || '/';
<     if (search && search !== '?') {
<         path += (search.charAt(0) === '?' ? search : `?${search}`);
<     }
<     if (hash && hash !== '#') {
<         path += (hash.charAt(0) === '#' ? hash : `#${hash}`);
<     }
<     return path;
< };
< const parseQueryString = (query) => {
<     if (!query) {
<         return {};
<     }
<     return (/^[?#]/.test(query) ? query.slice(1) : query)
<         .split('&')
<         .reduce((params, param) => {
<         let [key, value] = param.split('=');
<         params[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
<         return params;
<     }, {});
< };
< 
< const isAbsolute = (pathname) => {
<     return pathname.charAt(0) === '/';
< };
< const createKey = (keyLength) => {
<     return Math.random().toString(36).substr(2, keyLength);
< };
< // About 1.5x faster than the two-arg version of Array#splice()
< const spliceOne = (list, index) => {
<     for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
<         list[i] = list[k];
<     }
<     list.pop();
< };
< // This implementation is based heavily on node's url.parse
< const resolvePathname = (to, from = '') => {
<     let fromParts = from && from.split('/') || [];
<     let hasTrailingSlash;
<     let up = 0;
<     const toParts = to && to.split('/') || [];
<     const isToAbs = to && isAbsolute(to);
<     const isFromAbs = from && isAbsolute(from);
<     const mustEndAbs = isToAbs || isFromAbs;
<     if (to && isAbsolute(to)) {
<         // to is absolute
<         fromParts = toParts;
<     }
<     else if (toParts.length) {
<         // to is relative, drop the filename
<         fromParts.pop();
<         fromParts = fromParts.concat(toParts);
<     }
<     if (!fromParts.length) {
<         return '/';
<     }
<     if (fromParts.length) {
<         const last = fromParts[fromParts.length - 1];
<         hasTrailingSlash = (last === '.' || last === '..' || last === '');
<     }
<     else {
<         hasTrailingSlash = false;
<     }
<     for (let i = fromParts.length; i >= 0; i--) {
<         const part = fromParts[i];
<         if (part === '.') {
<             spliceOne(fromParts, i);
<         }
<         else if (part === '..') {
<             spliceOne(fromParts, i);
<             up++;
<         }
<         else if (up) {
<             spliceOne(fromParts, i);
<             up--;
<         }
<     }
<     if (!mustEndAbs) {
<         for (; up--; up) {
<             fromParts.unshift('..');
<         }
<     }
<     if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {
<         fromParts.unshift('');
<     }
<     let result = fromParts.join('/');
<     if (hasTrailingSlash && result.substr(-1) !== '/') {
<         result += '/';
<     }
<     return result;
< };
< const valueEqual = (a, b) => {
<     if (a === b) {
<         return true;
<     }
<     if (a == null || b == null) {
<         return false;
<     }
<     if (Array.isArray(a)) {
<         return Array.isArray(b) && a.length === b.length && a.every((item, index) => {
<             return valueEqual(item, b[index]);
<         });
<     }
<     const aType = typeof a;
<     const bType = typeof b;
<     if (aType !== bType) {
<         return false;
<     }
<     if (aType === 'object') {
<         const aValue = a.valueOf();
<         const bValue = b.valueOf();
<         if (aValue !== a || bValue !== b) {
<             return valueEqual(aValue, bValue);
<         }
<         const aKeys = Object.keys(a);
<         const bKeys = Object.keys(b);
<         if (aKeys.length !== bKeys.length) {
<             return false;
<         }
<         return aKeys.every((key) => {
<             return valueEqual(a[key], b[key]);
<         });
<     }
<     return false;
< };
< const locationsAreEqual = (a, b) => {
<     return a.pathname === b.pathname &&
<         a.search === b.search &&
<         a.hash === b.hash &&
<         a.key === b.key &&
<         valueEqual(a.state, b.state);
< };
< const createLocation = (path, state, key, currentLocation) => {
<     let location;
<     if (typeof path === 'string') {
<         // Two-arg form: push(path, state)
<         location = parsePath(path);
<         if (state !== undefined) {
<             location.state = state;
<         }
<     }
<     else {
<         // One-arg form: push(location)
<         location = Object.assign({ pathname: '' }, path);
<         if (location.search && location.search.charAt(0) !== '?') {
<             location.search = '?' + location.search;
<         }
<         if (location.hash && location.hash.charAt(0) !== '#') {
<             location.hash = '#' + location.hash;
<         }
<         if (state !== undefined && location.state === undefined) {
<             location.state = state;
<         }
<     }
<     try {
<         location.pathname = decodeURI(location.pathname);
<     }
<     catch (e) {
<         if (e instanceof URIError) {
<             throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' +
<                 'This is likely caused by an invalid percent-encoding.');
<         }
<         else {
<             throw e;
<         }
<     }
<     location.key = key;
<     if (currentLocation) {
<         // Resolve incomplete/relative pathname relative to current location.
<         if (!location.pathname) {
<             location.pathname = currentLocation.pathname;
<         }
<         else if (location.pathname.charAt(0) !== '/') {
<             location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
<         }
<     }
<     else {
<         // When there is no prior location and pathname is empty, set it to /
<         if (!location.pathname) {
<             location.pathname = '/';
<         }
<     }
<     location.query = parseQueryString(location.search || '');
<     return location;
< };
< 
< let cacheCount = 0;
< const patternCache = {};
< const cacheLimit = 10000;
< // Memoized function for creating the path match regex
< const compilePath = (pattern, options) => {
<     const cacheKey = `${options.end}${options.strict}`;
<     const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
<     const cachePattern = JSON.stringify(pattern);
<     if (cache[cachePattern]) {
<         return cache[cachePattern];
<     }
<     const keys = [];
<     const re = pathToRegexp(pattern, keys, options);
<     const compiledPattern = { re, keys };
<     if (cacheCount < cacheLimit) {
<         cache[cachePattern] = compiledPattern;
<         cacheCount += 1;
<     }
<     return compiledPattern;
< };
< /**
<  * Public API for matching a URL pathname to a path pattern.
<  */
< const matchPath = (pathname, options = {}) => {
<     if (typeof options === 'string') {
<         options = { path: options };
<     }
<     const { path = '/', exact = false, strict = false } = options;
<     const { re, keys } = compilePath(path, { end: exact, strict });
<     const match = re.exec(pathname);
<     if (!match) {
<         return null;
<     }
<     const [url, ...values] = match;
<     const isExact = pathname === url;
<     if (exact && !isExact) {
<         return null;
<     }
<     return {
<         path,
<         url: path === '/' && url === '' ? '/' : url,
<         isExact,
<         params: keys.reduce((memo, key, index) => {
<             memo[key.name] = values[index];
<             return memo;
<         }, {})
<     };
< };
< const matchesAreEqual = (a, b) => {
<     if (a == null && b == null) {
<         return true;
<     }
<     if (b == null) {
<         return false;
<     }
<     return a && b &&
<         a.path === b.path &&
<         a.url === b.url &&
<         valueEqual(a.params, b.params);
---
> /**
>  * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js
>  */
> /**
>  * Default configs.
>  */
> const DEFAULT_DELIMITER = '/';
> const DEFAULT_DELIMITERS = './';
> /**
>  * The main path matching regexp utility.
>  */
> const PATH_REGEXP = new RegExp([
>     // Match escaped characters that would otherwise appear in future matches.
>     // This allows the user to escape special characters that won't transform.
>     '(\\\\.)',
>     // Match Express-style parameters and un-named parameters with a prefix
>     // and optional suffixes. Matches appear as:
>     //
>     // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
>     // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
>     '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
> ].join('|'), 'g');
> /**
>  * Parse a string for the raw tokens.
>  */
> const parse = (str, options) => {
>     var tokens = [];
>     var key = 0;
>     var index = 0;
>     var path = '';
>     var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
>     var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;
>     var pathEscaped = false;
>     var res;
>     while ((res = PATH_REGEXP.exec(str)) !== null) {
>         var m = res[0];
>         var escaped = res[1];
>         var offset = res.index;
>         path += str.slice(index, offset);
>         index = offset + m.length;
>         // Ignore already escaped sequences.
>         if (escaped) {
>             path += escaped[1];
>             pathEscaped = true;
>             continue;
>         }
>         var prev = '';
>         var next = str[index];
>         var name = res[2];
>         var capture = res[3];
>         var group = res[4];
>         var modifier = res[5];
>         if (!pathEscaped && path.length) {
>             var k = path.length - 1;
>             if (delimiters.indexOf(path[k]) > -1) {
>                 prev = path[k];
>                 path = path.slice(0, k);
>             }
>         }
>         // Push the current path onto the tokens.
>         if (path) {
>             tokens.push(path);
>             path = '';
>             pathEscaped = false;
>         }
>         var partial = prev !== '' && next !== undefined && next !== prev;
>         var repeat = modifier === '+' || modifier === '*';
>         var optional = modifier === '?' || modifier === '*';
>         var delimiter = prev || defaultDelimiter;
>         var pattern = capture || group;
>         tokens.push({
>             name: name || key++,
>             prefix: prev,
>             delimiter: delimiter,
>             optional: optional,
>             repeat: repeat,
>             partial: partial,
>             pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
>         });
>     }
>     // Push any remaining characters.
>     if (path || index < str.length) {
>         tokens.push(path + str.substr(index));
>     }
>     return tokens;
> };
> /**
>  * Escape a regular expression string.
>  */
> const escapeString = (str) => {
>     return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
> };
> /**
>  * Escape the capturing group by escaping special characters and meaning.
>  */
> const escapeGroup = (group) => {
>     return group.replace(/([=!:$/()])/g, '\\$1');
> };
> /**
>  * Get the flags for a regexp from the options.
>  */
> const flags = (options) => {
>     return options && options.sensitive ? '' : 'i';
> };
> /**
>  * Pull out keys from a regexp.
>  */
> const regexpToRegexp = (path, keys) => {
>     if (!keys)
>         return path;
>     // Use a negative lookahead to match only capturing groups.
>     var groups = path.source.match(/\((?!\?)/g);
>     if (groups) {
>         for (var i = 0; i < groups.length; i++) {
>             keys.push({
>                 name: i,
>                 prefix: null,
>                 delimiter: null,
>                 optional: false,
>                 repeat: false,
>                 partial: false,
>                 pattern: null
>             });
>         }
>     }
>     return path;
> };
> /**
>  * Transform an array into a regexp.
>  */
> const arrayToRegexp = (path, keys, options) => {
>     var parts = [];
>     for (var i = 0; i < path.length; i++) {
>         parts.push(pathToRegexp(path[i], keys, options).source);
>     }
>     return new RegExp('(?:' + parts.join('|') + ')', flags(options));
> };
> /**
>  * Create a path regexp from string input.
>  */
> const stringToRegexp = (path, keys, options) => {
>     return tokensToRegExp(parse(path, options), keys, options);
> };
> /**
>  * Expose a function for taking tokens and returning a RegExp.
>  */
> const tokensToRegExp = (tokens, keys, options) => {
>     options = options || {};
>     var strict = options.strict;
>     var end = options.end !== false;
>     var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
>     var delimiters = options.delimiters || DEFAULT_DELIMITERS;
>     var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
>     var route = '';
>     var isEndDelimited = false;
>     // Iterate over the tokens and create our regexp string.
>     for (var i = 0; i < tokens.length; i++) {
>         var token = tokens[i];
>         if (typeof token === 'string') {
>             route += escapeString(token);
>             isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
>         }
>         else {
>             var prefix = escapeString(token.prefix || '');
>             var capture = token.repeat
>                 ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'
>                 : token.pattern;
>             if (keys)
>                 keys.push(token);
>             if (token.optional) {
>                 if (token.partial) {
>                     route += prefix + '(' + capture + ')?';
>                 }
>                 else {
>                     route += '(?:' + prefix + '(' + capture + '))?';
>                 }
>             }
>             else {
>                 route += prefix + '(' + capture + ')';
>             }
>         }
>     }
>     if (end) {
>         if (!strict)
>             route += '(?:' + delimiter + ')?';
>         route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
>     }
>     else {
>         if (!strict)
>             route += '(?:' + delimiter + '(?=' + endsWith + '))?';
>         if (!isEndDelimited)
>             route += '(?=' + delimiter + '|' + endsWith + ')';
>     }
>     return new RegExp('^' + route, flags(options));
> };
> /**
>  * Normalize the given path string, returning a regular expression.
>  *
>  * An empty array can be passed in for the keys, which will hold the
>  * placeholder key descriptions. For example, using `/user/:id`, `keys` will
>  * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
>  */
> const pathToRegexp = (path, keys, options) => {
>     if (path instanceof RegExp) {
>         return regexpToRegexp(path, keys);
>     }
>     if (Array.isArray(path)) {
>         return arrayToRegexp(path, keys, options);
>     }
>     return stringToRegexp(path, keys, options);
> };
> 
> const hasBasename = (path, prefix) => {
>     return (new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i')).test(path);
> };
> const stripBasename = (path, prefix) => {
>     return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
> };
> const stripTrailingSlash = (path) => {
>     return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
> };
> const addLeadingSlash = (path) => {
>     return path.charAt(0) === '/' ? path : '/' + path;
> };
> const stripLeadingSlash = (path) => {
>     return path.charAt(0) === '/' ? path.substr(1) : path;
> };
> const parsePath = (path) => {
>     let pathname = path || '/';
>     let search = '';
>     let hash = '';
>     const hashIndex = pathname.indexOf('#');
>     if (hashIndex !== -1) {
>         hash = pathname.substr(hashIndex);
>         pathname = pathname.substr(0, hashIndex);
>     }
>     const searchIndex = pathname.indexOf('?');
>     if (searchIndex !== -1) {
>         search = pathname.substr(searchIndex);
>         pathname = pathname.substr(0, searchIndex);
>     }
>     return {
>         pathname,
>         search: search === '?' ? '' : search,
>         hash: hash === '#' ? '' : hash,
>         query: {},
>         key: ''
>     };
> };
> const createPath = (location) => {
>     const { pathname, search, hash } = location;
>     let path = pathname || '/';
>     if (search && search !== '?') {
>         path += (search.charAt(0) === '?' ? search : `?${search}`);
>     }
>     if (hash && hash !== '#') {
>         path += (hash.charAt(0) === '#' ? hash : `#${hash}`);
>     }
>     return path;
> };
> const parseQueryString = (query) => {
>     if (!query) {
>         return {};
>     }
>     return (/^[?#]/.test(query) ? query.slice(1) : query)
>         .split('&')
>         .reduce((params, param) => {
>         let [key, value] = param.split('=');
>         params[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
>         return params;
>     }, {});
> };
> 
> const isAbsolute = (pathname) => {
>     return pathname.charAt(0) === '/';
> };
> const createKey = (keyLength) => {
>     return Math.random().toString(36).substr(2, keyLength);
> };
> // About 1.5x faster than the two-arg version of Array#splice()
> const spliceOne = (list, index) => {
>     for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
>         list[i] = list[k];
>     }
>     list.pop();
> };
> // This implementation is based heavily on node's url.parse
> const resolvePathname = (to, from = '') => {
>     let fromParts = from && from.split('/') || [];
>     let hasTrailingSlash;
>     let up = 0;
>     const toParts = to && to.split('/') || [];
>     const isToAbs = to && isAbsolute(to);
>     const isFromAbs = from && isAbsolute(from);
>     const mustEndAbs = isToAbs || isFromAbs;
>     if (to && isAbsolute(to)) {
>         // to is absolute
>         fromParts = toParts;
>     }
>     else if (toParts.length) {
>         // to is relative, drop the filename
>         fromParts.pop();
>         fromParts = fromParts.concat(toParts);
>     }
>     if (!fromParts.length) {
>         return '/';
>     }
>     if (fromParts.length) {
>         const last = fromParts[fromParts.length - 1];
>         hasTrailingSlash = (last === '.' || last === '..' || last === '');
>     }
>     else {
>         hasTrailingSlash = false;
>     }
>     for (let i = fromParts.length; i >= 0; i--) {
>         const part = fromParts[i];
>         if (part === '.') {
>             spliceOne(fromParts, i);
>         }
>         else if (part === '..') {
>             spliceOne(fromParts, i);
>             up++;
>         }
>         else if (up) {
>             spliceOne(fromParts, i);
>             up--;
>         }
>     }
>     if (!mustEndAbs) {
>         for (; up--; up) {
>             fromParts.unshift('..');
>         }
>     }
>     if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {
>         fromParts.unshift('');
>     }
>     let result = fromParts.join('/');
>     if (hasTrailingSlash && result.substr(-1) !== '/') {
>         result += '/';
>     }
>     return result;
> };
> const valueEqual = (a, b) => {
>     if (a === b) {
>         return true;
>     }
>     if (a == null || b == null) {
>         return false;
>     }
>     if (Array.isArray(a)) {
>         return Array.isArray(b) && a.length === b.length && a.every((item, index) => {
>             return valueEqual(item, b[index]);
>         });
>     }
>     const aType = typeof a;
>     const bType = typeof b;
>     if (aType !== bType) {
>         return false;
>     }
>     if (aType === 'object') {
>         const aValue = a.valueOf();
>         const bValue = b.valueOf();
>         if (aValue !== a || bValue !== b) {
>             return valueEqual(aValue, bValue);
>         }
>         const aKeys = Object.keys(a);
>         const bKeys = Object.keys(b);
>         if (aKeys.length !== bKeys.length) {
>             return false;
>         }
>         return aKeys.every((key) => {
>             return valueEqual(a[key], b[key]);
>         });
>     }
>     return false;
> };
> const locationsAreEqual = (a, b) => {
>     return a.pathname === b.pathname &&
>         a.search === b.search &&
>         a.hash === b.hash &&
>         a.key === b.key &&
>         valueEqual(a.state, b.state);
> };
> const createLocation = (path, state, key, currentLocation) => {
>     let location;
>     if (typeof path === 'string') {
>         // Two-arg form: push(path, state)
>         location = parsePath(path);
>         if (state !== undefined) {
>             location.state = state;
>         }
>     }
>     else {
>         // One-arg form: push(location)
>         location = Object.assign({ pathname: '' }, path);
>         if (location.search && location.search.charAt(0) !== '?') {
>             location.search = '?' + location.search;
>         }
>         if (location.hash && location.hash.charAt(0) !== '#') {
>             location.hash = '#' + location.hash;
>         }
>         if (state !== undefined && location.state === undefined) {
>             location.state = state;
>         }
>     }
>     try {
>         location.pathname = decodeURI(location.pathname);
>     }
>     catch (e) {
>         if (e instanceof URIError) {
>             throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' +
>                 'This is likely caused by an invalid percent-encoding.');
>         }
>         else {
>             throw e;
>         }
>     }
>     location.key = key;
>     if (currentLocation) {
>         // Resolve incomplete/relative pathname relative to current location.
>         if (!location.pathname) {
>             location.pathname = currentLocation.pathname;
>         }
>         else if (location.pathname.charAt(0) !== '/') {
>             location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
>         }
>     }
>     else {
>         // When there is no prior location and pathname is empty, set it to /
>         if (!location.pathname) {
>             location.pathname = '/';
>         }
>     }
>     location.query = parseQueryString(location.search || '');
>     return location;
> };
> 
> let cacheCount = 0;
> const patternCache = {};
> const cacheLimit = 10000;
> // Memoized function for creating the path match regex
> const compilePath = (pattern, options) => {
>     const cacheKey = `${options.end}${options.strict}`;
>     const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
>     const cachePattern = JSON.stringify(pattern);
>     if (cache[cachePattern]) {
>         return cache[cachePattern];
>     }
>     const keys = [];
>     const re = pathToRegexp(pattern, keys, options);
>     const compiledPattern = { re, keys };
>     if (cacheCount < cacheLimit) {
>         cache[cachePattern] = compiledPattern;
>         cacheCount += 1;
>     }
>     return compiledPattern;
> };
> /**
>  * Public API for matching a URL pathname to a path pattern.
>  */
> const matchPath = (pathname, options = {}) => {
>     if (typeof options === 'string') {
>         options = { path: options };
>     }
>     const { path = '/', exact = false, strict = false } = options;
>     const { re, keys } = compilePath(path, { end: exact, strict });
>     const match = re.exec(pathname);
>     if (!match) {
>         return null;
>     }
>     const [url, ...values] = match;
>     const isExact = pathname === url;
>     if (exact && !isExact) {
>         return null;
>     }
>     return {
>         path,
>         url: path === '/' && url === '' ? '/' : url,
>         isExact,
>         params: keys.reduce((memo, key, index) => {
>             memo[key.name] = values[index];
>             return memo;
>         }, {})
>     };
> };
> const matchesAreEqual = (a, b) => {
>     if (a == null && b == null) {
>         return true;
>     }
>     if (b == null) {
>         return false;
>     }
>     return a && b &&
>         a.path === b.path &&
>         a.url === b.url &&
>         valueEqual(a.params, b.params);
6114,6165c6147,6198
< const getConfirmation = (win, message, callback) => (callback(win.confirm(message)));
< const isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);
< /**
<  * Returns true if the HTML5 history API is supported. Taken from Modernizr.
<  *
<  * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
<  * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
<  * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
<  */
< const supportsHistory = (win) => {
<     const ua = win.navigator.userAgent;
<     if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
<         ua.indexOf('Mobile Safari') !== -1 &&
<         ua.indexOf('Chrome') === -1 &&
<         ua.indexOf('Windows Phone') === -1) {
<         return false;
<     }
<     return win.history && 'pushState' in win.history;
< };
< /**
<  * Returns true if browser fires popstate on hash change.
<  * IE10 and IE11 do not.
<  */
< const supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);
< /**
<  * Returns false if using go(n) with hash history causes a full page reload.
<  */
< const supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);
< const isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&
<     nav.userAgent.indexOf('CriOS') === -1);
< const storageAvailable = (win, type) => {
<     const storage = win[type];
<     const x = '__storage_test__';
<     try {
<         storage.setItem(x, x);
<         storage.removeItem(x);
<         return true;
<     }
<     catch (e) {
<         return e instanceof DOMException && (
<         // everything except Firefox
<         e.code === 22 ||
<             // Firefox
<             e.code === 1014 ||
<             // test name field too, because code might not be present
<             // everything except Firefox
<             e.name === 'QuotaExceededError' ||
<             // Firefox
<             e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
<             // acknowledge QuotaExceededError only if there's something already stored
<             storage.length !== 0;
<     }
---
> const getConfirmation = (win, message, callback) => (callback(win.confirm(message)));
> const isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);
> /**
>  * Returns true if the HTML5 history API is supported. Taken from Modernizr.
>  *
>  * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
>  * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
>  * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
>  */
> const supportsHistory = (win) => {
>     const ua = win.navigator.userAgent;
>     if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
>         ua.indexOf('Mobile Safari') !== -1 &&
>         ua.indexOf('Chrome') === -1 &&
>         ua.indexOf('Windows Phone') === -1) {
>         return false;
>     }
>     return win.history && 'pushState' in win.history;
> };
> /**
>  * Returns true if browser fires popstate on hash change.
>  * IE10 and IE11 do not.
>  */
> const supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);
> /**
>  * Returns false if using go(n) with hash history causes a full page reload.
>  */
> const supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);
> const isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&
>     nav.userAgent.indexOf('CriOS') === -1);
> const storageAvailable = (win, type) => {
>     const storage = win[type];
>     const x = '__storage_test__';
>     try {
>         storage.setItem(x, x);
>         storage.removeItem(x);
>         return true;
>     }
>     catch (e) {
>         return e instanceof DOMException && (
>         // everything except Firefox
>         e.code === 22 ||
>             // Firefox
>             e.code === 1014 ||
>             // test name field too, because code might not be present
>             // everything except Firefox
>             e.name === 'QuotaExceededError' ||
>             // Firefox
>             e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
>             // acknowledge QuotaExceededError only if there's something already stored
>             storage.length !== 0;
>     }
6416,6970c6449,7003
< const warning = (value, ...args) => {
<     if (!value) {
<         console.warn(...args);
<     }
< };
< 
< // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
< const createTransitionManager = () => {
<     let prompt;
<     let listeners = [];
<     const setPrompt = (nextPrompt) => {
<         warning(prompt == null, 'A history supports only one prompt at a time');
<         prompt = nextPrompt;
<         return () => {
<             if (prompt === nextPrompt) {
<                 prompt = null;
<             }
<         };
<     };
<     const confirmTransitionTo = (location, action, getUserConfirmation, callback) => {
<         // TODO: If another transition starts while we're still confirming
<         // the previous one, we may end up in a weird state. Figure out the
<         // best way to handle this.
<         if (prompt != null) {
<             const result = typeof prompt === 'function' ? prompt(location, action) : prompt;
<             if (typeof result === 'string') {
<                 if (typeof getUserConfirmation === 'function') {
<                     getUserConfirmation(result, callback);
<                 }
<                 else {
<                     warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
<                     callback(true);
<                 }
<             }
<             else {
<                 // Return false from a transition hook to cancel the transition.
<                 callback(result !== false);
<             }
<         }
<         else {
<             callback(true);
<         }
<     };
<     const appendListener = (fn) => {
<         let isActive = true;
<         const listener = (...args) => {
<             if (isActive) {
<                 fn(...args);
<             }
<         };
<         listeners.push(listener);
<         return () => {
<             isActive = false;
<             listeners = listeners.filter(item => item !== listener);
<         };
<     };
<     const notifyListeners = (...args) => {
<         listeners.forEach(listener => listener(...args));
<     };
<     return {
<         setPrompt,
<         confirmTransitionTo,
<         appendListener,
<         notifyListeners
<     };
< };
< 
< const createScrollHistory = (win, applicationScrollKey = 'scrollPositions') => {
<     let scrollPositions = new Map();
<     const set = (key, value) => {
<         scrollPositions.set(key, value);
<         if (storageAvailable(win, 'sessionStorage')) {
<             const arrayData = [];
<             scrollPositions.forEach((value, key) => {
<                 arrayData.push([key, value]);
<             });
<             win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData));
<         }
<     };
<     const get = (key) => {
<         return scrollPositions.get(key);
<     };
<     const has = (key) => {
<         return scrollPositions.has(key);
<     };
<     const capture = (key) => {
<         set(key, [win.scrollX, win.scrollY]);
<     };
<     if (storageAvailable(win, 'sessionStorage')) {
<         const scrollData = win.sessionStorage.getItem(applicationScrollKey);
<         scrollPositions = scrollData ?
<             new Map(JSON.parse(scrollData)) :
<             scrollPositions;
<     }
<     if ('scrollRestoration' in win.history) {
<         history.scrollRestoration = 'manual';
<     }
<     return {
<         set,
<         get,
<         has,
<         capture
<     };
< };
< 
< // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
< const PopStateEvent = 'popstate';
< const HashChangeEvent = 'hashchange';
< /**
<  * Creates a history object that uses the HTML5 history API including
<  * pushState, replaceState, and the popstate event.
<  */
< const createBrowserHistory = (win, props = {}) => {
<     let forceNextPop = false;
<     const globalHistory = win.history;
<     const globalLocation = win.location;
<     const globalNavigator = win.navigator;
<     const canUseHistory = supportsHistory(win);
<     const needsHashChangeListener = !supportsPopStateOnHashChange(globalNavigator);
<     const scrollHistory = createScrollHistory(win);
<     const forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;
<     const getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;
<     const keyLength = (props.keyLength != null) ? props.keyLength : 6;
<     const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
<     const getHistoryState = () => {
<         try {
<             return win.history.state || {};
<         }
<         catch (e) {
<             // IE 11 sometimes throws when accessing window.history.state
<             // See https://github.com/ReactTraining/history/pull/289
<             return {};
<         }
<     };
<     const getDOMLocation = (historyState) => {
<         historyState = historyState || {};
<         const { key, state } = historyState;
<         const { pathname, search, hash } = globalLocation;
<         let path = pathname + search + hash;
<         warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
<             'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
<         if (basename) {
<             path = stripBasename(path, basename);
<         }
<         return createLocation(path, state, key || createKey(keyLength));
<     };
<     const transitionManager = createTransitionManager();
<     const setState = (nextState) => {
<         // Capture location for the view before changing history.
<         scrollHistory.capture(history.location.key);
<         Object.assign(history, nextState);
<         // Set scroll position based on its previous storage value
<         history.location.scrollPosition = scrollHistory.get(history.location.key);
<         history.length = globalHistory.length;
<         transitionManager.notifyListeners(history.location, history.action);
<     };
<     const handlePopState = (event) => {
<         // Ignore extraneous popstate events in WebKit.
<         if (!isExtraneousPopstateEvent(globalNavigator, event)) {
<             handlePop(getDOMLocation(event.state));
<         }
<     };
<     const handleHashChange = () => {
<         handlePop(getDOMLocation(getHistoryState()));
<     };
<     const handlePop = (location) => {
<         if (forceNextPop) {
<             forceNextPop = false;
<             setState();
<         }
<         else {
<             const action = 'POP';
<             transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<                 if (ok) {
<                     setState({ action, location });
<                 }
<                 else {
<                     revertPop(location);
<                 }
<             });
<         }
<     };
<     const revertPop = (fromLocation) => {
<         const toLocation = history.location;
<         // TODO: We could probably make this more reliable by
<         // keeping a list of keys we've seen in sessionStorage.
<         // Instead, we just default to 0 for keys we don't know.
<         let toIndex = allKeys.indexOf(toLocation.key);
<         let fromIndex = allKeys.indexOf(fromLocation.key);
<         if (toIndex === -1) {
<             toIndex = 0;
<         }
<         if (fromIndex === -1) {
<             fromIndex = 0;
<         }
<         const delta = toIndex - fromIndex;
<         if (delta) {
<             forceNextPop = true;
<             go(delta);
<         }
<     };
<     const initialLocation = getDOMLocation(getHistoryState());
<     let allKeys = [initialLocation.key];
<     let listenerCount = 0;
<     let isBlocked = false;
<     // Public interface
<     const createHref = (location) => {
<         return basename + createPath(location);
<     };
<     const push = (path, state) => {
<         warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +
<             'argument is a location-like object that already has state; it is ignored');
<         const action = 'PUSH';
<         const location = createLocation(path, state, createKey(keyLength), history.location);
<         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<             if (!ok) {
<                 return;
<             }
<             const href = createHref(location);
<             const { key, state } = location;
<             if (canUseHistory) {
<                 globalHistory.pushState({ key, state }, '', href);
<                 if (forceRefresh) {
<                     globalLocation.href = href;
<                 }
<                 else {
<                     const prevIndex = allKeys.indexOf(history.location.key);
<                     const nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
<                     nextKeys.push(location.key);
<                     allKeys = nextKeys;
<                     setState({ action, location });
<                 }
<             }
<             else {
<                 warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');
<                 globalLocation.href = href;
<             }
<         });
<     };
<     const replace = (path, state) => {
<         warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +
<             'argument is a location-like object that already has state; it is ignored');
<         const action = 'REPLACE';
<         const location = createLocation(path, state, createKey(keyLength), history.location);
<         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<             if (!ok) {
<                 return;
<             }
<             const href = createHref(location);
<             const { key, state } = location;
<             if (canUseHistory) {
<                 globalHistory.replaceState({ key, state }, '', href);
<                 if (forceRefresh) {
<                     globalLocation.replace(href);
<                 }
<                 else {
<                     const prevIndex = allKeys.indexOf(history.location.key);
<                     if (prevIndex !== -1) {
<                         allKeys[prevIndex] = location.key;
<                     }
<                     setState({ action, location });
<                 }
<             }
<             else {
<                 warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');
<                 globalLocation.replace(href);
<             }
<         });
<     };
<     const go = (n) => {
<         globalHistory.go(n);
<     };
<     const goBack = () => go(-1);
<     const goForward = () => go(1);
<     const checkDOMListeners = (delta) => {
<         listenerCount += delta;
<         if (listenerCount === 1) {
<             win.addEventListener(PopStateEvent, handlePopState);
<             if (needsHashChangeListener) {
<                 win.addEventListener(HashChangeEvent, handleHashChange);
<             }
<         }
<         else if (listenerCount === 0) {
<             win.removeEventListener(PopStateEvent, handlePopState);
<             if (needsHashChangeListener) {
<                 win.removeEventListener(HashChangeEvent, handleHashChange);
<             }
<         }
<     };
<     const block = (prompt = '') => {
<         const unblock = transitionManager.setPrompt(prompt);
<         if (!isBlocked) {
<             checkDOMListeners(1);
<             isBlocked = true;
<         }
<         return () => {
<             if (isBlocked) {
<                 isBlocked = false;
<                 checkDOMListeners(-1);
<             }
<             return unblock();
<         };
<     };
<     const listen = (listener) => {
<         const unlisten = transitionManager.appendListener(listener);
<         checkDOMListeners(1);
<         return () => {
<             checkDOMListeners(-1);
<             unlisten();
<         };
<     };
<     const history = {
<         length: globalHistory.length,
<         action: 'POP',
<         location: initialLocation,
<         createHref,
<         push,
<         replace,
<         go,
<         goBack,
<         goForward,
<         block,
<         listen,
<         win: win
<     };
<     return history;
< };
< 
< // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
< const HashChangeEvent$1 = 'hashchange';
< const HashPathCoders = {
<     hashbang: {
<         encodePath: (path) => path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path),
<         decodePath: (path) => path.charAt(0) === '!' ? path.substr(1) : path
<     },
<     noslash: {
<         encodePath: stripLeadingSlash,
<         decodePath: addLeadingSlash
<     },
<     slash: {
<         encodePath: addLeadingSlash,
<         decodePath: addLeadingSlash
<     }
< };
< const createHashHistory = (win, props = {}) => {
<     let forceNextPop = false;
<     let ignorePath = null;
<     let listenerCount = 0;
<     let isBlocked = false;
<     const globalLocation = win.location;
<     const globalHistory = win.history;
<     const canGoWithoutReload = supportsGoWithoutReloadUsingHash(win.navigator);
<     const keyLength = (props.keyLength != null) ? props.keyLength : 6;
<     const { getUserConfirmation = getConfirmation, hashType = 'slash' } = props;
<     const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
<     const { encodePath, decodePath } = HashPathCoders[hashType];
<     const getHashPath = () => {
<         // We can't use window.location.hash here because it's not
<         // consistent across browsers - Firefox will pre-decode it!
<         const href = globalLocation.href;
<         const hashIndex = href.indexOf('#');
<         return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
<     };
<     const pushHashPath = (path) => (globalLocation.hash = path);
<     const replaceHashPath = (path) => {
<         const hashIndex = globalLocation.href.indexOf('#');
<         globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
<     };
<     const getDOMLocation = () => {
<         let path = decodePath(getHashPath());
<         warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
<             'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
<         if (basename) {
<             path = stripBasename(path, basename);
<         }
<         return createLocation(path, undefined, createKey(keyLength));
<     };
<     const transitionManager = createTransitionManager();
<     const setState = (nextState) => {
<         Object.assign(history, nextState);
<         history.length = globalHistory.length;
<         transitionManager.notifyListeners(history.location, history.action);
<     };
<     const handleHashChange = () => {
<         const path = getHashPath();
<         const encodedPath = encodePath(path);
<         if (path !== encodedPath) {
<             // Ensure we always have a properly-encoded hash.
<             replaceHashPath(encodedPath);
<         }
<         else {
<             const location = getDOMLocation();
<             const prevLocation = history.location;
<             if (!forceNextPop && locationsAreEqual(prevLocation, location)) {
<                 return; // A hashchange doesn't always == location change.
<             }
<             if (ignorePath === createPath(location)) {
<                 return; // Ignore this change; we already setState in push/replace.
<             }
<             ignorePath = null;
<             handlePop(location);
<         }
<     };
<     const handlePop = (location) => {
<         if (forceNextPop) {
<             forceNextPop = false;
<             setState();
<         }
<         else {
<             const action = 'POP';
<             transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<                 if (ok) {
<                     setState({ action, location });
<                 }
<                 else {
<                     revertPop(location);
<                 }
<             });
<         }
<     };
<     const revertPop = (fromLocation) => {
<         const toLocation = history.location;
<         // TODO: We could probably make this more reliable by
<         // keeping a list of paths we've seen in sessionStorage.
<         // Instead, we just default to 0 for paths we don't know.
<         let toIndex = allPaths.lastIndexOf(createPath(toLocation));
<         let fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
<         if (toIndex === -1) {
<             toIndex = 0;
<         }
<         if (fromIndex === -1) {
<             fromIndex = 0;
<         }
<         const delta = toIndex - fromIndex;
<         if (delta) {
<             forceNextPop = true;
<             go(delta);
<         }
<     };
<     // Ensure the hash is encoded properly before doing anything else.
<     const path = getHashPath();
<     const encodedPath = encodePath(path);
<     if (path !== encodedPath) {
<         replaceHashPath(encodedPath);
<     }
<     const initialLocation = getDOMLocation();
<     let allPaths = [createPath(initialLocation)];
<     // Public interface
<     const createHref = (location) => ('#' + encodePath(basename + createPath(location)));
<     const push = (path, state) => {
<         warning(state === undefined, 'Hash history cannot push state; it is ignored');
<         const action = 'PUSH';
<         const location = createLocation(path, undefined, createKey(keyLength), history.location);
<         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<             if (!ok) {
<                 return;
<             }
<             const path = createPath(location);
<             const encodedPath = encodePath(basename + path);
<             const hashChanged = getHashPath() !== encodedPath;
<             if (hashChanged) {
<                 // We cannot tell if a hashchange was caused by a PUSH, so we'd
<                 // rather setState here and ignore the hashchange. The caveat here
<                 // is that other hash histories in the page will consider it a POP.
<                 ignorePath = path;
<                 pushHashPath(encodedPath);
<                 const prevIndex = allPaths.lastIndexOf(createPath(history.location));
<                 const nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
<                 nextPaths.push(path);
<                 allPaths = nextPaths;
<                 setState({ action, location });
<             }
<             else {
<                 warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
<                 setState();
<             }
<         });
<     };
<     const replace = (path, state) => {
<         warning(state === undefined, 'Hash history cannot replace state; it is ignored');
<         const action = 'REPLACE';
<         const location = createLocation(path, undefined, createKey(keyLength), history.location);
<         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
<             if (!ok) {
<                 return;
<             }
<             const path = createPath(location);
<             const encodedPath = encodePath(basename + path);
<             const hashChanged = getHashPath() !== encodedPath;
<             if (hashChanged) {
<                 // We cannot tell if a hashchange was caused by a REPLACE, so we'd
<                 // rather setState here and ignore the hashchange. The caveat here
<                 // is that other hash histories in the page will consider it a POP.
<                 ignorePath = path;
<                 replaceHashPath(encodedPath);
<             }
<             const prevIndex = allPaths.indexOf(createPath(history.location));
<             if (prevIndex !== -1) {
<                 allPaths[prevIndex] = path;
<             }
<             setState({ action, location });
<         });
<     };
<     const go = (n) => {
<         warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
<         globalHistory.go(n);
<     };
<     const goBack = () => go(-1);
<     const goForward = () => go(1);
<     const checkDOMListeners = (win, delta) => {
<         listenerCount += delta;
<         if (listenerCount === 1) {
<             win.addEventListener(HashChangeEvent$1, handleHashChange);
<         }
<         else if (listenerCount === 0) {
<             win.removeEventListener(HashChangeEvent$1, handleHashChange);
<         }
<     };
<     const block = (prompt = '') => {
<         const unblock = transitionManager.setPrompt(prompt);
<         if (!isBlocked) {
<             checkDOMListeners(win, 1);
<             isBlocked = true;
<         }
<         return () => {
<             if (isBlocked) {
<                 isBlocked = false;
<                 checkDOMListeners(win, -1);
<             }
<             return unblock();
<         };
<     };
<     const listen = (listener) => {
<         const unlisten = transitionManager.appendListener(listener);
<         checkDOMListeners(win, 1);
<         return () => {
<             checkDOMListeners(win, -1);
<             unlisten();
<         };
<     };
<     const history = {
<         length: globalHistory.length,
<         action: 'POP',
<         location: initialLocation,
<         createHref,
<         push,
<         replace,
<         go,
<         goBack,
<         goForward,
<         block,
<         listen,
<         win: win
<     };
<     return history;
---
> const warning = (value, ...args) => {
>     if (!value) {
>         console.warn(...args);
>     }
> };
> 
> // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
> const createTransitionManager = () => {
>     let prompt;
>     let listeners = [];
>     const setPrompt = (nextPrompt) => {
>         warning(prompt == null, 'A history supports only one prompt at a time');
>         prompt = nextPrompt;
>         return () => {
>             if (prompt === nextPrompt) {
>                 prompt = null;
>             }
>         };
>     };
>     const confirmTransitionTo = (location, action, getUserConfirmation, callback) => {
>         // TODO: If another transition starts while we're still confirming
>         // the previous one, we may end up in a weird state. Figure out the
>         // best way to handle this.
>         if (prompt != null) {
>             const result = typeof prompt === 'function' ? prompt(location, action) : prompt;
>             if (typeof result === 'string') {
>                 if (typeof getUserConfirmation === 'function') {
>                     getUserConfirmation(result, callback);
>                 }
>                 else {
>                     warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
>                     callback(true);
>                 }
>             }
>             else {
>                 // Return false from a transition hook to cancel the transition.
>                 callback(result !== false);
>             }
>         }
>         else {
>             callback(true);
>         }
>     };
>     const appendListener = (fn) => {
>         let isActive = true;
>         const listener = (...args) => {
>             if (isActive) {
>                 fn(...args);
>             }
>         };
>         listeners.push(listener);
>         return () => {
>             isActive = false;
>             listeners = listeners.filter(item => item !== listener);
>         };
>     };
>     const notifyListeners = (...args) => {
>         listeners.forEach(listener => listener(...args));
>     };
>     return {
>         setPrompt,
>         confirmTransitionTo,
>         appendListener,
>         notifyListeners
>     };
> };
> 
> const createScrollHistory = (win, applicationScrollKey = 'scrollPositions') => {
>     let scrollPositions = new Map();
>     const set = (key, value) => {
>         scrollPositions.set(key, value);
>         if (storageAvailable(win, 'sessionStorage')) {
>             const arrayData = [];
>             scrollPositions.forEach((value, key) => {
>                 arrayData.push([key, value]);
>             });
>             win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData));
>         }
>     };
>     const get = (key) => {
>         return scrollPositions.get(key);
>     };
>     const has = (key) => {
>         return scrollPositions.has(key);
>     };
>     const capture = (key) => {
>         set(key, [win.scrollX, win.scrollY]);
>     };
>     if (storageAvailable(win, 'sessionStorage')) {
>         const scrollData = win.sessionStorage.getItem(applicationScrollKey);
>         scrollPositions = scrollData ?
>             new Map(JSON.parse(scrollData)) :
>             scrollPositions;
>     }
>     if ('scrollRestoration' in win.history) {
>         history.scrollRestoration = 'manual';
>     }
>     return {
>         set,
>         get,
>         has,
>         capture
>     };
> };
> 
> // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
> const PopStateEvent = 'popstate';
> const HashChangeEvent = 'hashchange';
> /**
>  * Creates a history object that uses the HTML5 history API including
>  * pushState, replaceState, and the popstate event.
>  */
> const createBrowserHistory = (win, props = {}) => {
>     let forceNextPop = false;
>     const globalHistory = win.history;
>     const globalLocation = win.location;
>     const globalNavigator = win.navigator;
>     const canUseHistory = supportsHistory(win);
>     const needsHashChangeListener = !supportsPopStateOnHashChange(globalNavigator);
>     const scrollHistory = createScrollHistory(win);
>     const forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;
>     const getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;
>     const keyLength = (props.keyLength != null) ? props.keyLength : 6;
>     const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
>     const getHistoryState = () => {
>         try {
>             return win.history.state || {};
>         }
>         catch (e) {
>             // IE 11 sometimes throws when accessing window.history.state
>             // See https://github.com/ReactTraining/history/pull/289
>             return {};
>         }
>     };
>     const getDOMLocation = (historyState) => {
>         historyState = historyState || {};
>         const { key, state } = historyState;
>         const { pathname, search, hash } = globalLocation;
>         let path = pathname + search + hash;
>         warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
>             'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
>         if (basename) {
>             path = stripBasename(path, basename);
>         }
>         return createLocation(path, state, key || createKey(keyLength));
>     };
>     const transitionManager = createTransitionManager();
>     const setState = (nextState) => {
>         // Capture location for the view before changing history.
>         scrollHistory.capture(history.location.key);
>         Object.assign(history, nextState);
>         // Set scroll position based on its previous storage value
>         history.location.scrollPosition = scrollHistory.get(history.location.key);
>         history.length = globalHistory.length;
>         transitionManager.notifyListeners(history.location, history.action);
>     };
>     const handlePopState = (event) => {
>         // Ignore extraneous popstate events in WebKit.
>         if (!isExtraneousPopstateEvent(globalNavigator, event)) {
>             handlePop(getDOMLocation(event.state));
>         }
>     };
>     const handleHashChange = () => {
>         handlePop(getDOMLocation(getHistoryState()));
>     };
>     const handlePop = (location) => {
>         if (forceNextPop) {
>             forceNextPop = false;
>             setState();
>         }
>         else {
>             const action = 'POP';
>             transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>                 if (ok) {
>                     setState({ action, location });
>                 }
>                 else {
>                     revertPop(location);
>                 }
>             });
>         }
>     };
>     const revertPop = (fromLocation) => {
>         const toLocation = history.location;
>         // TODO: We could probably make this more reliable by
>         // keeping a list of keys we've seen in sessionStorage.
>         // Instead, we just default to 0 for keys we don't know.
>         let toIndex = allKeys.indexOf(toLocation.key);
>         let fromIndex = allKeys.indexOf(fromLocation.key);
>         if (toIndex === -1) {
>             toIndex = 0;
>         }
>         if (fromIndex === -1) {
>             fromIndex = 0;
>         }
>         const delta = toIndex - fromIndex;
>         if (delta) {
>             forceNextPop = true;
>             go(delta);
>         }
>     };
>     const initialLocation = getDOMLocation(getHistoryState());
>     let allKeys = [initialLocation.key];
>     let listenerCount = 0;
>     let isBlocked = false;
>     // Public interface
>     const createHref = (location) => {
>         return basename + createPath(location);
>     };
>     const push = (path, state) => {
>         warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +
>             'argument is a location-like object that already has state; it is ignored');
>         const action = 'PUSH';
>         const location = createLocation(path, state, createKey(keyLength), history.location);
>         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>             if (!ok) {
>                 return;
>             }
>             const href = createHref(location);
>             const { key, state } = location;
>             if (canUseHistory) {
>                 globalHistory.pushState({ key, state }, '', href);
>                 if (forceRefresh) {
>                     globalLocation.href = href;
>                 }
>                 else {
>                     const prevIndex = allKeys.indexOf(history.location.key);
>                     const nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
>                     nextKeys.push(location.key);
>                     allKeys = nextKeys;
>                     setState({ action, location });
>                 }
>             }
>             else {
>                 warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');
>                 globalLocation.href = href;
>             }
>         });
>     };
>     const replace = (path, state) => {
>         warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +
>             'argument is a location-like object that already has state; it is ignored');
>         const action = 'REPLACE';
>         const location = createLocation(path, state, createKey(keyLength), history.location);
>         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>             if (!ok) {
>                 return;
>             }
>             const href = createHref(location);
>             const { key, state } = location;
>             if (canUseHistory) {
>                 globalHistory.replaceState({ key, state }, '', href);
>                 if (forceRefresh) {
>                     globalLocation.replace(href);
>                 }
>                 else {
>                     const prevIndex = allKeys.indexOf(history.location.key);
>                     if (prevIndex !== -1) {
>                         allKeys[prevIndex] = location.key;
>                     }
>                     setState({ action, location });
>                 }
>             }
>             else {
>                 warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');
>                 globalLocation.replace(href);
>             }
>         });
>     };
>     const go = (n) => {
>         globalHistory.go(n);
>     };
>     const goBack = () => go(-1);
>     const goForward = () => go(1);
>     const checkDOMListeners = (delta) => {
>         listenerCount += delta;
>         if (listenerCount === 1) {
>             win.addEventListener(PopStateEvent, handlePopState);
>             if (needsHashChangeListener) {
>                 win.addEventListener(HashChangeEvent, handleHashChange);
>             }
>         }
>         else if (listenerCount === 0) {
>             win.removeEventListener(PopStateEvent, handlePopState);
>             if (needsHashChangeListener) {
>                 win.removeEventListener(HashChangeEvent, handleHashChange);
>             }
>         }
>     };
>     const block = (prompt = '') => {
>         const unblock = transitionManager.setPrompt(prompt);
>         if (!isBlocked) {
>             checkDOMListeners(1);
>             isBlocked = true;
>         }
>         return () => {
>             if (isBlocked) {
>                 isBlocked = false;
>                 checkDOMListeners(-1);
>             }
>             return unblock();
>         };
>     };
>     const listen = (listener) => {
>         const unlisten = transitionManager.appendListener(listener);
>         checkDOMListeners(1);
>         return () => {
>             checkDOMListeners(-1);
>             unlisten();
>         };
>     };
>     const history = {
>         length: globalHistory.length,
>         action: 'POP',
>         location: initialLocation,
>         createHref,
>         push,
>         replace,
>         go,
>         goBack,
>         goForward,
>         block,
>         listen,
>         win: win
>     };
>     return history;
> };
> 
> // Adapted from the https://github.com/ReactTraining/history and converted to TypeScript
> const HashChangeEvent$1 = 'hashchange';
> const HashPathCoders = {
>     hashbang: {
>         encodePath: (path) => path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path),
>         decodePath: (path) => path.charAt(0) === '!' ? path.substr(1) : path
>     },
>     noslash: {
>         encodePath: stripLeadingSlash,
>         decodePath: addLeadingSlash
>     },
>     slash: {
>         encodePath: addLeadingSlash,
>         decodePath: addLeadingSlash
>     }
> };
> const createHashHistory = (win, props = {}) => {
>     let forceNextPop = false;
>     let ignorePath = null;
>     let listenerCount = 0;
>     let isBlocked = false;
>     const globalLocation = win.location;
>     const globalHistory = win.history;
>     const canGoWithoutReload = supportsGoWithoutReloadUsingHash(win.navigator);
>     const keyLength = (props.keyLength != null) ? props.keyLength : 6;
>     const { getUserConfirmation = getConfirmation, hashType = 'slash' } = props;
>     const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
>     const { encodePath, decodePath } = HashPathCoders[hashType];
>     const getHashPath = () => {
>         // We can't use window.location.hash here because it's not
>         // consistent across browsers - Firefox will pre-decode it!
>         const href = globalLocation.href;
>         const hashIndex = href.indexOf('#');
>         return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
>     };
>     const pushHashPath = (path) => (globalLocation.hash = path);
>     const replaceHashPath = (path) => {
>         const hashIndex = globalLocation.href.indexOf('#');
>         globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
>     };
>     const getDOMLocation = () => {
>         let path = decodePath(getHashPath());
>         warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
>             'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
>         if (basename) {
>             path = stripBasename(path, basename);
>         }
>         return createLocation(path, undefined, createKey(keyLength));
>     };
>     const transitionManager = createTransitionManager();
>     const setState = (nextState) => {
>         Object.assign(history, nextState);
>         history.length = globalHistory.length;
>         transitionManager.notifyListeners(history.location, history.action);
>     };
>     const handleHashChange = () => {
>         const path = getHashPath();
>         const encodedPath = encodePath(path);
>         if (path !== encodedPath) {
>             // Ensure we always have a properly-encoded hash.
>             replaceHashPath(encodedPath);
>         }
>         else {
>             const location = getDOMLocation();
>             const prevLocation = history.location;
>             if (!forceNextPop && locationsAreEqual(prevLocation, location)) {
>                 return; // A hashchange doesn't always == location change.
>             }
>             if (ignorePath === createPath(location)) {
>                 return; // Ignore this change; we already setState in push/replace.
>             }
>             ignorePath = null;
>             handlePop(location);
>         }
>     };
>     const handlePop = (location) => {
>         if (forceNextPop) {
>             forceNextPop = false;
>             setState();
>         }
>         else {
>             const action = 'POP';
>             transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>                 if (ok) {
>                     setState({ action, location });
>                 }
>                 else {
>                     revertPop(location);
>                 }
>             });
>         }
>     };
>     const revertPop = (fromLocation) => {
>         const toLocation = history.location;
>         // TODO: We could probably make this more reliable by
>         // keeping a list of paths we've seen in sessionStorage.
>         // Instead, we just default to 0 for paths we don't know.
>         let toIndex = allPaths.lastIndexOf(createPath(toLocation));
>         let fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
>         if (toIndex === -1) {
>             toIndex = 0;
>         }
>         if (fromIndex === -1) {
>             fromIndex = 0;
>         }
>         const delta = toIndex - fromIndex;
>         if (delta) {
>             forceNextPop = true;
>             go(delta);
>         }
>     };
>     // Ensure the hash is encoded properly before doing anything else.
>     const path = getHashPath();
>     const encodedPath = encodePath(path);
>     if (path !== encodedPath) {
>         replaceHashPath(encodedPath);
>     }
>     const initialLocation = getDOMLocation();
>     let allPaths = [createPath(initialLocation)];
>     // Public interface
>     const createHref = (location) => ('#' + encodePath(basename + createPath(location)));
>     const push = (path, state) => {
>         warning(state === undefined, 'Hash history cannot push state; it is ignored');
>         const action = 'PUSH';
>         const location = createLocation(path, undefined, createKey(keyLength), history.location);
>         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>             if (!ok) {
>                 return;
>             }
>             const path = createPath(location);
>             const encodedPath = encodePath(basename + path);
>             const hashChanged = getHashPath() !== encodedPath;
>             if (hashChanged) {
>                 // We cannot tell if a hashchange was caused by a PUSH, so we'd
>                 // rather setState here and ignore the hashchange. The caveat here
>                 // is that other hash histories in the page will consider it a POP.
>                 ignorePath = path;
>                 pushHashPath(encodedPath);
>                 const prevIndex = allPaths.lastIndexOf(createPath(history.location));
>                 const nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
>                 nextPaths.push(path);
>                 allPaths = nextPaths;
>                 setState({ action, location });
>             }
>             else {
>                 warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
>                 setState();
>             }
>         });
>     };
>     const replace = (path, state) => {
>         warning(state === undefined, 'Hash history cannot replace state; it is ignored');
>         const action = 'REPLACE';
>         const location = createLocation(path, undefined, createKey(keyLength), history.location);
>         transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {
>             if (!ok) {
>                 return;
>             }
>             const path = createPath(location);
>             const encodedPath = encodePath(basename + path);
>             const hashChanged = getHashPath() !== encodedPath;
>             if (hashChanged) {
>                 // We cannot tell if a hashchange was caused by a REPLACE, so we'd
>                 // rather setState here and ignore the hashchange. The caveat here
>                 // is that other hash histories in the page will consider it a POP.
>                 ignorePath = path;
>                 replaceHashPath(encodedPath);
>             }
>             const prevIndex = allPaths.indexOf(createPath(history.location));
>             if (prevIndex !== -1) {
>                 allPaths[prevIndex] = path;
>             }
>             setState({ action, location });
>         });
>     };
>     const go = (n) => {
>         warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
>         globalHistory.go(n);
>     };
>     const goBack = () => go(-1);
>     const goForward = () => go(1);
>     const checkDOMListeners = (win, delta) => {
>         listenerCount += delta;
>         if (listenerCount === 1) {
>             win.addEventListener(HashChangeEvent$1, handleHashChange);
>         }
>         else if (listenerCount === 0) {
>             win.removeEventListener(HashChangeEvent$1, handleHashChange);
>         }
>     };
>     const block = (prompt = '') => {
>         const unblock = transitionManager.setPrompt(prompt);
>         if (!isBlocked) {
>             checkDOMListeners(win, 1);
>             isBlocked = true;
>         }
>         return () => {
>             if (isBlocked) {
>                 isBlocked = false;
>                 checkDOMListeners(win, -1);
>             }
>             return unblock();
>         };
>     };
>     const listen = (listener) => {
>         const unlisten = transitionManager.appendListener(listener);
>         checkDOMListeners(win, 1);
>         return () => {
>             checkDOMListeners(win, -1);
>             unlisten();
>         };
>     };
>     const history = {
>         length: globalHistory.length,
>         action: 'POP',
>         location: initialLocation,
>         createHref,
>         push,
>         replace,
>         go,
>         goBack,
>         goForward,
>         block,
>         listen,
>         win: win
>     };
>     return history;
7131c7164
<   AppRoot,
---
>   ...__stencil__.fetchRegisteredComponents(),
7143c7176
< exports.hydrateApp = hydrateApp;
---
> __stencil__.hydrateApp = hydrateApp;
7897,7900c7930,7947
< exports.createWindowFromHtml = createWindowFromHtml;
< exports.hydrateDocument = hydrateDocument;
< exports.renderToString = renderToString;
< exports.serializeDocumentToString = serializeDocumentToString;
---
> __stencil__.createWindowFromHtml = createWindowFromHtml;
> __stencil__.hydrateDocument = hydrateDocument;
> __stencil__.renderToString = renderToString;
> __stencil__.serializeDocumentToString = serializeDocumentToString;
> 
> __stencil__.renderOnSsr = async (CompClass, props) => {
>   const tagName = `${CompClass.cmpMeta.$tagName$}`
>   const attributes = Object.keys(CompClass.cmpMeta.$members$).map(k => `${k}="${`${props[k]}`}"`).join(' ')
>   __stencil__.registry.push(CompClass);
> 	const { html, diagnostics } = await __stencil__.renderToString(`<${tagName} ${attributes}></${tagName}>`);
>   if (html) {
>     return html;
>   }
>   const [ { messageText } ] = diagnostics
>   throw new Error(messageText)
> }
> 
> console.log(`%%%% initialized __stencil__`)
